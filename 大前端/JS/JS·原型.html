<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS·原型与原型链</title>
</head>
<body>
    <script>

        console.log('Function:', Function)
        console.log('Function.prototype:', Function.prototype)
        console.log('Function.__proto__:', Function.__proto__)
        console.log('Function.prototype.__proto__:', Function.prototype.__proto__)
        console.log('Function.prototype === Function.__proto__:', Function.prototype === Function.__proto__)
        console.log('\n\n')

        console.log('Object:', Object)
        console.log('Object.prototype:', Object.prototype)
        console.log('Object.__proto__:', Object.__proto__)
        console.log('Object.prototype.__proto__:', Object.prototype.__proto__)
        console.log('\n\n')

        function Person() {
            Person.prototype.drink = function(food) {}
        }
        var obj1 = new Person()

        console.log('Person:', Person)
        console.log('Person.prototype:', Person.prototype)
        console.log('Person.__proto__:', Person.__proto__)
        console.log('Person.prototype.__proto__:', Person.prototype.__proto__)
        console.log('\n\n')

        console.log('obj1:', obj1)
        console.log('obj1.prototype:', obj1.prototype)
        console.log('obj1.__proto__:', obj1.__proto__)
        console.log('\n\n')


        console.log(Person.prototype)

        console.log(obj1.__proto__ === Person.prototype)
        console.log('Object === Person.prototype', Object.prototype === Person.prototype.__proto__)
        console.log('Function.prototype === Person.__proto__', Function.prototype === Person.__proto__)
        console.log('Object.prototype.__proto__',  Object.prototype.__proto__)
        console.log('Function.prototype === Object.__proto__', Function.prototype === Object.__proto__)
        console.log('Function.prototype.__proto__ === Object.prototype', Function.prototype.__proto__ === Object.prototype)

    </script>
</body>
</html>

<!-- 
    在 JS 内部所有的函数都属于对象
    在 JS 内部，所有的函数都属于内置构造函数 Function 的实例
    在 JS 内部, Object.prototype 叫做顶级模型，不再有 __proto__；


    Prototype 原型
    * 定义：每一个函数天生自带一个属性，叫做 prototype，是一个对象；
    * 构造函数也是函数，也会有这个自带控件 prototype
    * 每一个对象自带一个 __proto__ ，指向所属构造函数的 prototype : obj4.__proto__ === Person.prototype
        * 访问对象成员时，首先在自己身上查找，找不到再去 __proto__ 上查找
        * 访问对象函数时，首先在自己身上查找，找不到再去  __proto__ 上查找
    * 一般将对象的函数放在 prototype 上，这样子可以只占用一份内存 
    *
    * 1、实例对象身上的 __proto__ 指向谁？指向所属构造函数的 prototype
        * obj 所属的构造函数是 Person()
        * obj.__proto__ === Person.prototype
    * 2、构造函数 Person.prototype 的 __proto__ 指向谁？
        * Person.prototype 是一个对象数据类型 Object
        * 在 JS 内部所有的 Object 数据类型都属于 Object 这个内置构造函数
        * Person.prototype 属于 Object 内置构造函数
        * Person.prototype.__proto__ === Object.prototype
    * 3、Person 的  __proto__ 指向谁？
        * Person 是一个构造函数，而函数本身也是一个对象，因此 Person 也有 __proto__；
        * 在 JS 内部，所有的函数都属于内置构造函数 Function 的实例
        * 因此 Person.__proto__ === Function.prototype
    * 4、Object.prototype 的  __proto__ 指向谁？
        * Object.prototype 是一个对象数据类型，只要是对象，都是 Object 这个内置构造函数的
        * Object.prototype 在 JS 内部叫做顶级模型，不再有 __proto__；
        * Object.prototype.__proto__ === null
    * 5、Object 的  __proto__ 指向谁？
        * Object 是一个内置构造函数，因此也是一个对象；
        * Object 也是 Function 的实例
        * Object.__proto__ === Function.prototype
    * 6、Function.prototype 的  __proto__ 指向谁？
        * Function.prototype 也是一个对象数据类型
        * Function.prototype.__proto__ === Object.prototype
    * 7、Function 的  __proto__ 指向谁？
        * Function 也是一个内置构造函数；
        * Function 自己是自己的构造函数；
        * Function 自己是自己的实例对象
    *
    *
    *
    * 原型链：使用 __proto__ 串联起来的对象链结构
        * 每一个实例对象，都有一个属于自己的原型链
            * 实例.__proto__ === 类.prototype
            * 类.prototype.__proto__ = Object.prototype
            * Object.prototype.__proto__ = null
        * OC: 实例.isa = 类； 类.isa = 元类； 元类.isa = 根元类；根元类.isa = 根类；根类.isa = null;
        * 作用：为了访问对象成员；
    * 对象访问机制：
        * 首先在自己身上查找，如果找到则直接使用；
        * 如果没有，则沿着 __proto__ 去原型链查找；
        * 直到 Object.prototype 都没有，那么返回 undefined;
 -->
